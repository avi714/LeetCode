Return an Array such that A[i] is the product of the entire array except A[i]

A. Brute Force: Use 2 for loops and for each element scan the entire array and take a product of the elements except the current element. Time Complexity: O(n**2)
	
B. PreFix and PostFix array: The intuition is that for every number we multiple the right side of it and the left side of it except for index 0 and -1 where we dont have both the sides and as a result we consider 1 to be on the missing side. E.g. [1,2,3,4] for 2 we multiply the sub array to its left and the sub array to its right but for 1 there is no left sub array. As a result we consider a sub array to its left to be of 1's. Same for 4 we consider the right sub array to be of 1's. Create two arrays one prefix and postfix and traverse the array once from start to end for prefix array and once end to start for postfix array. For the prefix array we initialize prefix[0] as 1 and for the rest of the elements we do prefix[i-1]*nums[i-1]. For the postfix array we initialize of postfix[-1] as 1 and for the rest of the elements we do postfix[i+1]*nums[i+1]. Time Complexity: O(3n). Space Complexity: O(3n)
	
C. Single Pass with Prefix & Postfix Variables: Instead of creating three arrays, we can solve this using one result array and two variables: prefix and postfix. Initialize both prefix and postfix with 1. The result array will store the intermediate product while the prefix and postfix variables will store the running product. For the prefix calculation, iterate through the array from start to end.  At each step, set result[i] = prefix, then update prefix as prefix *= nums[i]. For the postfix calculation, iterate through the array from end to start. At each step, update result[i] = result[i] * postfix, then update postfix as postfix *= nums[i]. Time Complexity: O(2n). Space Complexity: O(1) (output array not counted, as required by problem).
