Problem Statement: Return i,j,k such that A[i] + A[j] + A[k] = 0 and i!=j!=k and the solutions are unique and not repeated.

A. Brute Force: Use three nested for loops to iterate through the array and find all possible triplets (A[i], A[j], A[k]) that sum to zero. For each triplet, check whether it already exists in the result set; if it does, ignore it; otherwise, add it. Time Complexity: O(n**3). Space Complexity: O(1)
	
B. 2Sum - HashSet: We use a result set (rSet) to handle duplicate triplets. For every A[i], we create a temporary set (visitedSet) to store values of A[j] seen so far.  Then, for each A[j] (where j starts from i+1), we calculate the complement: complement = target - A[i] - A[j] (in this problem, the target is 0). If the complement exists in visitedSet, then we’ve found a valid triplet. We sort the triplet (A[i], A[j], complement) and add it as a tuple to rSet (sorting ensures uniqueness, and tuples are hashable in Python while sets are not). If the complement doesn’t exist, we add A[j] to visitedSet. In Java, since tuples aren't built-in, we can use lists, sort them, and add to a Set<List<Integer>>. Sorting ensures uniqueness, so that results like [-1,2,-1] and [2,-1,-1] are treated as the same triplet rather than different ones. Time Complexity: O(n**2). Space Complexity: O(n)
	
C. 2Sum - Sorting and Two Pointer: To eliminate duplicates, we first sort the array. Then, for each A[i], we skip it if it is the same as A[i-1], since using the same starting value would result in duplicate triplets. Next, we initialize two pointers: l = i + 1 and r = len(A) - 1. While l < r, we check whether A[i] + A[l] + A[r] == target. If so, we add the triplet to the result list and move the left pointer forward, skipping duplicate values  (A[l] == A[l-1]) to avoid repeated results.(We achieve this  by using a while loop in this condition that continues incrementing l while A[l] == A[l-1]). If the sum is less than the target, we increment l; if it's greater, we decrement r. For example, if A[i] = -2 in one solution, we should not use A[i] = -2 again in another, as the resulting triplets would likely be duplicates. Therefore, during the ith iteration, we add a condition to skip A[i] if it's equal to A[i-1]. For the right pointer we don't need to explicitly check for duplicates. By skipping duplicates for the left pointer, we naturally avoid duplicate results from the right side. If A[r] == A[r-1], the sum will be greater than target - A[i], and as the array is sorted, we automatically move r leftward. For example, given the array [-2, -2, 0, 0, 2, 2], if we skip the second -2 at index 1 (for l), the right pointer still starts at the end. When checking a combination like 0 + 2, if the result is greater than target - A[i], we decrement r. Time Complexity: O(n**2). Space Complexity: O(1)
